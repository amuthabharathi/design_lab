// File Name : cpu.v
// Module Name : cpu_8bit
// The heart of the entire SoC controlling memory and the peripherals to act
// together
// It is 8 bit processor which adopts two cycle operation where in instructions are supplied from the testbench by reading the mem file
// generated by the assembler and the instructions are properly decoded,
// executed and written back to the registers

`include "defines.v"

module cpu_8bit
(
	// Inputs
	clk,
	rst_n, 
	ins_out, 

	// Outputs
	addr1, 
	addr2, 
	addr3, 
	wen, 
	reg_a, 
	reg_b, 
	data_out, 
	pc
);

	input 		clk, rst_n;
	input	[15:0] 	ins_out;
	
	output	[6:0] 	pc;
	output  [7:0] 	data_out; // This goes to peripheral registers to be written
	output  [3:0] 	addr1;
	output  [3:0]	addr2;
	output  [3:0]	addr3;
	output		wen;
	output [7:0]	reg_a;
	output	[7:0]	reg_b;
	
	wire  [15:0] ins_out;
	
	reg		wen;
	reg    	[3:0] 	addr1;
	reg   	[3:0] 	addr2;
	reg   	[3:0] 	addr3;
	reg 	[7:0] 	op_a = 0;
	reg 	[7:0] 	op_b = 0;
	reg 	[6:0] 	pc;
	
	wire rst_hlt_n;
	
	always@(posedge(clk))
	begin
		if(rst_n == 0)
			pc <= 0;
		else if(rst_hlt_n!=0)
			pc <= pc+1;
	end
	
	assign rst_hlt_n = !(ins_out[15:12] == `HLT);
	
	always @(posedge clk)
	  wen <= (ins_out[15:12] != `NOP && ins_out[15:12] != `HLT)&rst_n;
	
	always @(posedge clk)
	  addr3 <= ins_out[11:8];
	//Decode or operands muxing part
	always@(*)
	begin
		addr1 = 4'h0;
		addr2 = 4'h0;
		case (ins_out[15:12])
		`ADD, `SUB, `AND, `OR: begin 
			addr1 = ins_out[7:4];
			addr2 = ins_out[3:0];
			op_a  = reg_a;
			op_b  = reg_b;
			end
		`MVI: begin
			op_a = ins_out[7:0];
			end
		`BC,	`BS: begin
			addr1=ins_out[11:8];
			op_a=reg_a;
			op_b=ins_out[7:0];
			end
		`ADDI, `SUBI: begin
			addr1 = ins_out[11:8];
			op_a = reg_a;
			op_b = ins_out[7:0];
			end
		`NOT, `MOV: begin
			addr1 = ins_out[7:4];
			op_a = reg_a;
			end
	
	endcase
	
	end
	
	// Instruction Memory
	// one and zero are hard coded for future advancements in the SoC to input the
	// instructions from external pins
	//ins_mem instruction_memory(pc, one, zero, ins_out);
	
	// General Purpose Register File R0 - R7
	register gpr (clk, addr1,addr2, addr3, wen, data_out, reg_a, reg_b);
	
	// ALU
	alu 	 a_l_u(ins_out[15:12],op_a, op_b, data_out);

endmodule
